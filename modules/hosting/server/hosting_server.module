<?php

/**
 * Hook implementations for the Hosting server module
 */

include_once "hosting_server.service.inc";
include_once "hosting.ip.inc";

/**
 * Implements hook_node_info().
 */
function hosting_server_node_info() {
  $types["server"] =  array(
    "type" => 'server',
    "name" => t('Server'),
    'base' => 'hosting_server',
    "has_title" => TRUE,
    "title_label" => t('Host name'),
    "description" => hosting_node_help("server"),
    "has_body" => 0,
    "body_label" => '',
    "min_word_count" => 0,
  );
  return $types;
}


/**
 * Implements hook_menu().
 */
function hosting_server_menu() {
  $items = array();

  $items['hosting/servers'] = array(
    'title' => 'Servers',
    'description' => 'List of servers',
    'page callback' => 'hosting_server_listing',
    'access arguments' => array('view server'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['hosting/servers/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['hosting/servers/add'] = array(
    'title' => 'Add server',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_goto',
    'page arguments' => array('node/add/server'),
    'access callback' => 'node_access',
    'access arguments' => array('create', 'server'),
  );

  return $items;
}

/**
 * Implements hook_hosting_feature().
 */
function hosting_server_hosting_feature() {
  $features['server'] = array(
    'title' => t('Server administration'),
    'description' => t('Manage multiple servers.'),
    'status' => HOSTING_FEATURE_ENABLED,
    'node' => 'server',
  );
  return $features;
}

/**
 * Implements hook_hosting_tasks().
 */
function hosting_server_hosting_tasks() {
  $tasks = array();
  $tasks['server']['verify'] = array(
    'title' => t('Verify'),
    'description' => t('Verify that the server is correctly installed and working.'),
    'weight' => 10,
    'provision_save' => TRUE,
  );

  /**
   * @TODO: support various other tasks like Delete
   $tasks['server']['delete'] = array(
   'title' => t('Delete'),
   'description' => t('Delete the server.'),
   );
   */

  return $tasks;
}

/**
 * Implements hook_permission().
 */
function hosting_server_permission() {
  return array(
    'create server' => array(
      'title' => t('create server'),
      'description' => t('TODO Add a description for \'create server\''),
    ),
    'view server' => array(
      'title' => t('view server'),
      'description' => t('TODO Add a description for \'view server\''),
    ),
    'edit server' => array(
      'title' => t('edit server'),
      'description' => t('TODO Add a description for \'edit server\''),
    ),
    'delete server' => array(
      'title' => t('delete server'),
      'description' => t('TODO Add a description for \'delete server\''),
    ),
  );
}

/**
 * Implements hook_node_access().
 */
function hosting_server_node_access($node, $op, $account) {
  if (!hosting_feature('server')) {
    return FALSE;
  }
  switch ($op) {
    case 'create':
      return user_access('create server', $account);

    case 'view':
      return user_access('view server', $account);

    case 'update':
      return user_access('edit server', $account);

    case 'delete':
      return user_access('delete server', $account);
  }
}

/**
 * Return an associative array of services enabled on this system.
 */
function hosting_server_services() {
  static $services;

  if (!isset($services)) {
    $services = module_invoke_all('hosting_service_type');
    foreach (module_implements('hosting_service') as $module) {
      foreach (module_invoke($module, 'hosting_service') as $service => $service_type) {
        module_load_include('service.inc', $module);
        $services[$service_type]['types'][$service] = 'hostingService_' . $service_type . '_' . $service;
      }
    }
  }

  return $services;
}

/**
 * Factory method for generating new instance of a service class.
 */
function hosting_services_new_object($name, $type, $node, $values = NULL) {
  $services = hosting_server_services();

  $class = $services[$name]['types'][$type];
  if (!$class) {
    return;
  }
  return new $class($node, $values);
}

/**
 * Add a service to an existing server node.
 */
function hosting_services_add(&$node, $name, $type, $values = array()) {
  $values['available'] = (isset($values['available'])) ? $values['available'] : 1;

  if ($service_object = hosting_services_new_object($name, $type, $node, $values)) {
    $node->services[$name] = $service_object;
  }
}

/**
 * Initializes the service objects associated with a server node object.
 *
 * @param
 *   $node The server node object.
 *
 * @return
 *   The server node object with an additional 'services' property. The
 *   services property is an associative array with the name of the service
 *   as key, and the service object as value.
 */
function hosting_server_init_services(&$node) {
  $node->services = array();
  $result = db_query("SELECT service, type FROM {hosting_service} WHERE vid = :vid AND available = :available", array(':vid' => $node->vid, ':available' => 1));
  while ($record = $result->fetch()) {
    $name = $record->service;
    if ($service_object = hosting_services_new_object($name, $record->type, $node)) {
      $node->services[$name] = $service_object;
    }
  }

  return $node;
}

/**
 * Translate a server form submission into populated server objects on the node.*/
function hosting_server_services_from_post(&$node) {
  if (isset($node->services) && is_array($node->services)) {
    foreach (hosting_server_services() as $name => $data) {
      if (isset($node->services[$name]) && is_array($node->services[$name])) {
        if ($node->services[$name]['type'] !== 'null') {
          if ($service_object = hosting_services_new_object($name, $node->services[$name]['type'], $node, $node->services[$name][$node->services[$name]['type']])) {
            $node->services[$name] = hosting_services_new_object($name, $node->services[$name]['type'], $node, $node->services[$name][$node->services[$name]['type']]);
            $node->services[$name]->available = TRUE;
          }
        }
        else {
          unset($node->services[$name]);
        }
      }
    }
  }
}

/**
 * Invoke a method on all enabled services.
 */
function hosting_server_invoke_services(&$node, $method, &$arg1 = NULL, &$arg2 = NULL, &$arg3 = NULL, &$arg4 = NULL) {
  $return = array();
  foreach ($node->services as $name => $service) {
    $result = $service->$method($arg1, $arg2, $arg3, $arg4);
    if (isset($result) && is_array($result)) {
      $return = array_merge_recursive($return, $result);
    }
    elseif (isset($result)) {
      $return[] = $result;
    }
  }
  return $return;
}


/**
 * Implements hook_form().
 */
function hosting_server_form($node, &$form_state) {
  drupal_add_js(drupal_get_path('module', 'hosting_server') . '/hosting_server.js');
  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Server hostname'),
    '#required' => TRUE,
    '#default_value' => $node->title,
    '#description' => t('The host name of the server. This is the address that will be used by Hostmaster to connect to the server to issue commands. It is to resolve to the internal network, if you have such a separation.<br /><strong>Be careful when changing the node title, it is used to create the SQL users if the IP address, below, is not set.</strong>'),
    '#weight' => -10,
  );

  $form['ip_addresses'] = array(
    '#type' => 'textarea',
    '#title' => t('Ip addresses'),
    '#description' => t('A list of IP addresses this server is publicly available under, one per line. If none is specified, a DNS lookup will be performed based on the server hostname above. <br /><strong>This should point to the public network, if you have such a separation.</strong>'),
    '#default_value' => isset($node->ip_addresses) ? implode("\n", _hosting_ip_list($node->ip_addresses)) : NULL,
    '#weight' => -9,
  );


  $form['services'] = array(
    '#weight' => -5,
    '#tree' => TRUE,
  );

  if (!isset($node->nid)) {
    $node->services = array();
  }

  foreach (hosting_server_services() as $name => $service) {
    $form['services'][$name] = array(
      '#type' => 'fieldset',
      '#title' => check_plain($service['title']),
      '#prefix' => '<div class="hosting-service-form">',
      '#suffix' => '</div>',
      '#weight' => isset($service['weight']) ? $service['weight'] : 0,
    );

    $form['services'][$name]['type'] = array(
      '#type' => 'radios',
      '#weight' => -99,
      '#options' => array_merge(array('null' => 'None'), drupal_map_assoc(array_keys($service['types']))),
      '#default_value' => isset($node->services[$name]->available) && $node->services[$name]->available ? $node->services[$name]->type : 'null',
    );

    // Service-specific configuration.
    foreach ($service['types'] as $type => $class) {
      $form['services'][$name][$type] = array(
        '#prefix' => '<div id="provision-service-settings-' . $name . '-' . $type . '" class="provision-service-settings-' . $name . '">',
        '#suffix' => '</div>',
      );
      if (isset($node->services[$name]) && $node->services[$name]->type === $type) {
        $node->services[$name]->form($form['services'][$name][$type]);
      }
      else {
        $service_object = hosting_services_new_object($name, $type, $node);
        $service_object->form($form['services'][$name][$type]);
      }
    }
  }

  return $form;
}

/**
 * Implementation of hook_presave()
 *
 * We resolve the server name to IP addresses if none has been given
 * by the operator. we also fire up the regular services hooks.
 */
function hosting_nodeapi_server_presave(&$node) {
  if (empty($node->ip_addresses)) {
    // this returns an array or FALSE
    $ips = gethostbynamel($node->title);
    if ($ips) {
      drupal_set_message(t('Initialized the IP to %ip based on hostname %name. If an HTTP service is enabled, this will be used to create database grants so make sure it is the right address, as seen from the database server.', array('%ip' => join(',', $ips), '%name' => $node->title)), 'message');
      $node->ip_addresses = $ips;
    }
    else {
      drupal_set_message(t("Could not resolve IP address of server %name, not automatically setting IP address. DNS may fail.", array('%name' => $node->title)));
    }
  }
  hosting_server_services_from_post($node);
}

/**
 * Implements hook_validate().
 */
function hosting_server_validate(&$node, &$form) {

  hosting_ip_validate($node);
  if (!_hosting_valid_fqdn($node->title)) {
    form_set_error('title', t('Invalid hostname. Use a proper hostname or an IP address.'));
  }

  if (!$node->nid && db_query("SELECT COUNT(nid) FROM {node} WHERE type = :type AND title = :title", array(':type' => 'server', ':title' => $node->title))->fetchField()) {
    form_set_error('title', t("The hostname you have specified is already in use."));
  }

  hosting_server_services_from_post($node);

  hosting_server_invoke_services($node, 'validate', $node, $form);
}


/**
 * Implements hook_update().
 *
 * As an existing node is being updated in the database, we need to do our own
 * database updates.
 */
function hosting_server_update($node) {
  // if this is a new node or we're adding a new revision,
  if (!empty($node->revision)) {
    hosting_server_insert($node);
  }
  else {
    hosting_server_invoke_services($node, 'save', $node);
    hosting_server_invoke_services($node, 'update', $node);

    // Remove disabled services
    foreach (array_diff(array_keys(hosting_server_services()), array_keys($node->services)) as $name) {
      db_delete('hosting_service')
        ->condition('service', $name)
        ->condition('nid', $node->nid)
        ->execute();
    }
  }

  hosting_ip_save($node, TRUE);

  if (!isset($node->no_verify) || !$node->no_verify) {
    hosting_add_task($node->nid, 'verify');
  }
}

/**
 * Implements hook_insert().
 */
function hosting_server_insert($node) {
  if (!$node->revision) {
    $hosting_name = isset($node->hosting_name) ? $node->hosting_name : 'server_' . preg_replace("/[!\W\.\-]/", "", $node->title);
    hosting_context_register($node->nid, $hosting_name );
  }

  $id = db_insert('hosting_server')
    ->fields(array(
      'vid' => $node->vid,
      'nid' => $node->nid,
    ))
    ->execute();

  hosting_ip_save($node, FALSE);

  hosting_server_invoke_services($node, 'save', $node);
  hosting_server_invoke_services($node, 'insert', $node);

  if (!isset($node->no_verify) || !$node->no_verify) {
    hosting_add_task($node->nid, 'verify');
  }
}

/**
 * Implementation of hook_delete_revision().
 */
function hosting_nodeapi_server_delete_revision(&$node) {
  db_delete('hosting_server')
    ->condition('vid', $node->vid)
    ->execute();
  hosting_ip_delete_revision($node);
  hosting_server_invoke_services($node, 'delete_revision');
}

/**
 * Implements hook_delete().
 */
function hosting_server_delete($node) {
  db_delete('hosting_server')
    ->condition('nid', $node->nid)
    ->execute();
  hosting_ip_delete($node);
  hosting_context_delete($node->nid);
  hosting_server_invoke_services($node, 'delete_revision');
}

/**
 * Implements hook_load().
 */
function hosting_server_load($nodes) {
  foreach ($nodes as $nid => &$node) {
    hosting_server_init_services($node);
    hosting_server_invoke_services($node, 'load');
    $additions = new stdClass();
    $additions->services = $node->services;
    $additions->ip_addresses = hosting_ip_load($node);

    foreach ($additions as $property => &$value) {
      $node->$property = $value;
    }
  }
}

/**
 * Menu callback; loads a hosting_task_server node
 *
 * @arg $arg a numeric nid
 */
function hosting_server_node_load($arg) {
  if (!is_numeric($arg)) {
    return FALSE;
  }
  if ($node = node_load($arg)) {
    if ($node->type === 'server') {
      return $node;
    }
  }
  return FALSE;
}


/**
 * Implements hook_view().
 */
function hosting_server_view(&$node, $teaser = FALSE, $page = FALSE) {
  hosting_set_breadcrumb($node);

  $services = hosting_server_services();

  $node->content['info'] = array(
    '#prefix' => '<div id="hosting-server-info" class="hosting-info-list">',
    '#suffix' => '</div>',
  );

  hosting_ip_view($node);
  if (isset($node->content->info->ip_addresses['#weight'])) {
    $node->content->info->ip_addresses['#weight'] = -30;
  }

  if (isset($node->services)) {
    foreach ($node->services as $name => $service) {
      $node->content['info'][$name] = array(
        '#prefix' => '<div class="hosting-service-info hosting-service-' . $name . '-info">',
        '#suffix' => '</div>',
      );
      if (isset($services[$name]['weight'])) {
        $node->content['info'][$name]['#weight'] = $services[$name]['weight'];
      }

      $title = $services[$name]['title'] . ' : ' . $service->type;

      $node->content['info'][$name]['title'] = array(
        '#value' => '<h3>' . $title . '</h3>',
        '#weight' => -20,
      );

      $service->view($node->content['info'][$name]);
    }
  }

  if ($page) {
    // Task list
    if (isset($node->nid)) {
      $node->content['tasks_view'] = array(
        '#type' => 'item',
        '#value' => hosting_task_table($node),
        '#prefix' => '<div id="hosting-task-list">',
        '#suffix' => '</div>',
        '#weight' => 10,
      );
      $settings['hostingTaskRefresh'] = array(
        'nid' => $node->nid,
        'changed' => $node->changed,
      );
      drupal_add_js($settings, array('type' => 'setting', 'scope' => JS_DEFAULT));

      drupal_add_js(drupal_get_path('module', 'hosting_task') . '/hosting_task.js');
    }
  }

  return $node;
}

/**
 * Output a table of servers with their enabled services.
 */

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function hosting_server_listing() {
  $services = hosting_server_services();
  $header = array(t('Server'));
  foreach ($services as $service => $data) {
    if ($service !== 'server') {
      $header[] = $data['title'];
    }
  }
  // TODO Confirm these are equivalent, especially the db_rewrite_sql() -> addTag('node_access').
  //$result = db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type='server' AND n.status = 1 ORDER BY n.title"));
  $result = db_select('node', 'n')
    ->addField('n', 'nid')
    ->condition('type', 'server')
    ->condition('status', 1)
    ->orderBy('title')
    ->addTag('node_access')
    ->execute();
  $rows = array();
  while ($obj = $result->fetch()) {
    $row = array();
    $server = node_load($obj->nid);
    $row[] = l($server->title, 'node/' . $server->nid);
    foreach ($services as $service => $data) {
      if ($service !== 'server') {
        if ($server->services[$service]->available) {
          $row[] = array(
            'class' => 'hosting-service-available',
            'data' => $server->services[$service]->type,
          );
        }
        else {
          $row[] = array(
            'class' => 'hosting-service-unavailable',
            'data' => t('No'),
          );
        }
      }
    }
    $rows[] = $row;
  }

  return theme('table', array('header' =>   $header, 'rows' => $rows, 'attributes' => array('class' => 'hosting-table')));
}

/**
 * Get servers providing a service.
 *
 * @param $service
 *   Service type string, like 'http' or 'db'
 *
 * @return
 *   An array of enabled servers, keys are the nid's of the nodes representing
 *   them, values are the titles of the servers.
 *
 * @see hook_hosting_servers_titles_alter()
 */
function hosting_get_servers($service) {
  $return = array();
  $result = db_query("SELECT n.nid, n.title FROM {node} n INNER JOIN {hosting_service} s ON n.vid = s.vid AND s.available = 1 AND s.service = '%s'", $service);
  while ($server = $result->fetch()) {
    $return[$server->nid] = $server->title;
  }
  drupal_alter('hosting_servers_titles', $return, $service);
  return $return;
}
