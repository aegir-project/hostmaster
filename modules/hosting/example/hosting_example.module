<?php
// $Id$

/**
 * @file
 * Example of the Hosting Services API.
 *
 * Aegir introduces an object representation of the provisioned
 * services that need to be implemented in both it's front end 
 * and backend.
 */

/**
 * @defgroup hostingserviceapi Frontend Service API
 * @{
 *
 * The "service API" is what makes Aegir capable of managing multiple
 * services like web or database servers. It provides a level of
 * abstraction that allows different implementations of a specific
 * service type.
 */

/**
 * Expose a type of service to the Service API.
 *
 * Return a new type of service (such as http, dns, db etc.) to
 * the service API.
 *
 * This information will be used to display the server node form,
 * allowing you to create services of this type.
 *
 * Just defining a service type without any implementations of it,
 * will automatically provide the "None" implementation.
 *
 * You will then need to create a new file in the same directory
 * as your module named "$module.service.inc, containing at
 * least a single class named "provisionService_$service", which
 * extends the base provisionService class.
 *
 * @see hosting_server_services()
 * @return
 *    an associative array with the index declaring the service
 *    type, and containing another associative array of properties.
 *    At present only the 'title' property is required for display
 *    of the server node form.
 */
function hosting_example_hosting_service_type() {
  return array(
    'example' => array(       // Machine name
      'title' => t('Example service'), // Human-readable name
      'weight' => 0,       // Optional, defaults to 0
    ),
  );
}

/**
 * Expose a service implementation to the service API.
 *
 * Return a service implementation, such as the "apache" implementation
 * of the "http" service.
 *
 * An implementation class should go in {module name}.service.inc and be must be
 * named hostingService_{service type}_{type}, which should be a subclass of
 * hostingService_{service type} or hostingService.
 *
 * You will then need to either extend the existing {module name}.service.inc
 * file, or create a new file, containing the implementation of your service.
 *
 * @return
 *   An associative array with the service implementation as key, and the
 *   service type implemented as value.
 *
 * @see hosting_server_services()
 */
function hosting_example_hosting_service() {
  return array('basic' => 'example');   // Service implementation => service type.
}

/**
 * @} End of "defgroup hostingserviceapi".
 */

/**
 * @defgroup quotahooks Quota subsystem
 * @{
 */

/**
 * Definition of hook_hosting_quota_resource
 */
function hosting_example_hosting_quota_resource() {
  $resources = array();

  $resources['foo'] = array(
    'title' => t('Foo'),
    'description' => t('Limit for foo. Enter in 23rds of foo units.'),
    'module' => 'hook',
  );

  return $resources;
}

/**
 * Definition of hook_hosting_quota_get_usage
 *
 * @param $client int
 *   The nid of the client node
 * @param $resource string
 *   The machine name of the resource
 * @param $start string
 *   A MySQL format date
 * @param $end string
 *   Another MySQL format date
 * @return int
 *   Return an integer that can be compared to what the quota is set to
 */
function hosting_example_hosting_quota_get_usage($client, $resource, $start, $end) {

  if (hosting_get_client($client)) {
    switch ($resource) {
      case 'foo':
        // Do some things
        return $usage;
    }
  }
}

/**
 * Definition of hook_hosting_quota_resource_render
 *
 * @param $resource string
 *   Machine name of the resource
 * @param $usage int
 *   Usage as returned by hosting_quota_get_usage
 */
function hosting_example_hosting_quota_resource_render($resource, $usage) {
  switch ($resource) {
    case 'foo':
      $bar = 23;
      return $usage * $bar . ' units';
  }
}

/**
 * @} End of "defgroup quotahooks".
 */

/**
 * @defgroup sitehooks Site hooks
 * @{
 */

/**
 *
 * @param $return
 *  An array of arrays, keys are fields on the $node and values are valid
 *  options for those fields.
 * @param $node
 *   The node object that represents the site.
 *
 * @see hosting_site_available_options()
 */
function hosting_example_hosting_site_options_alter(&$return, $node) {
  // From: hosting_ssl_hosting_site_options_alter().

  // Disable the ssl key fields by default.
  if (!sizeof(hosting_ssl_get_servers())) {
    $return['ssl_enabled'] = FALSE;
  }

  $return['ssl_key'] = false;
  $return['ssl_key_new'] = false;

  // Test if ssl has been enabled.
  if ($node->ssl_enabled != 0) {

    $keys = hosting_ssl_get_keys($node->client, TRUE);

    // return the list of valid keys, including the special 'new key' option.
    $return['ssl_key'] = array_keys($keys);

    // properly default this value so things dont fall apart later.
    if (sizeof($return['ssl_key']) == 1) {
      $node->ssl_key = HOSTING_SSL_CUSTOM_KEY;
    }

    // the user has chosen to enter a new key
    if ($node->ssl_key == HOSTING_SSL_CUSTOM_KEY) {
      // default the new key to the site's domain name, after filtering.
      $default = hosting_ssl_filter_key($node->title);
      $return['ssl_key_new'] = (!empty($default)) ? $default : true;
    }

    // we need to ensure that the return value is properly indexed, otherwise it
    // gets interpreted as an object by jquery.
    $return['profile'] = array_values(array_intersect($return['profile'], hosting_ssl_get_profiles()));

    $return['platform'] = array_values(array_intersect($return['platform'], hosting_ssl_get_platforms()));
  }
}

/**
 * @see hosting_task_confirm_form()
 * @see hosting_site_list_form()
 */
function hosting_task_TASK_TYPE_form($node) {

}

/**
 * @see hosting_task_confirm_form()
 */
function hosting_task_TASK_TYPE_form_validate() {

}

/**
 * @} End of "addtogroup hooks".
 */

/**
 * @addtogroup backend-frontend-IPC
 * @{
 */

/**
 * Define tasks that can be executed in the front-end.
 *
 * @return
 *   An array of arrays of tasks that can be executed by the front-end.
 *   The keys of the outer array should be the object that tasks operate on, for
 *   example 'site', 'platform' or 'server'. The values of the outer array
 *   should be an array of tasks keyed by task type, the value should be an
 *   array that defines the task. Valid keys for defining tasks are:
 *   - 'title': (required) The human readable name of the task.
 *   - 'description': (optional) The human readable description of the task.
 *   - 'weight': (optional) The weight of the task when displayed in lists.
 *   - 'dialog' (optional) Set to TRUE to indicate that this task requires a
 *      dialog to be shown to the user to confirm the execution of the task.
 *   - 'hidden' (optional) Set to TRUE to hide the task in the front-end UI, the
 *      task will still be available for execution by the front-end however.
 *   - 'access callback' (optional) An access callback to determine if the user
 *      can access the task, defaults to 'hosting_task_menu_access'.
 *
 * @see hosting_available_tasks()
 */
function hosting_example_hosting_tasks() {
  // From hosting_clone_hosting_tasks().
  $options = array();

  $options['site']['clone'] = array(
    'title' => t('Clone'),
    'description' => t('Make a copy of a site.'),
    'weight' => 5,
    'dialog' => TRUE,
  );
  return $options;
}

/**
 * @} End of "addtogroup hooks".
 */
